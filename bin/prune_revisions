#!/usr/bin/perl -w
# Copyright (C) 2016  Dean Serenevy
#
# Permission is hereby granted, free of charge, to any person obtaining a
# copy of this software and associated documentation files (the "Software"),
# to deal in the Software without restriction, including without limitation
# the rights to use, copy, modify, merge, publish, distribute, sublicense,
# and/or sell copies of the Software, and to permit persons to whom the
# Software is furnished to do so, subject to the following conditions:
#
# The above copyright notice and this permission notice shall be included in
# all copies or substantial portions of the Software.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
# IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
# FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL
# THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
# LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
# FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
# DEALINGS IN THE SOFTWARE.
use strict; use warnings; use 5.014;

use Getopt::Long qw/:config bundling/;
use Hash::Util qw/ lock_keys /;
our $VERSION = '0.2.1';# Created: 2015-12-05

our %OPT = ( keep_major => 2, keep_history => 2, keep_time => "3 months" );
our @OPT_SPEC =
qw/ help|h version noact|no-act|dry-run DEBUG
  /;
sub USAGE { <<"__USAGE__" };
usage: $_[0] [options]
__USAGE__

use JSON;
use Dean::Util qw/ natural_sort parse_date /;

get_options( \%OPT, @OPT_SPEC );
MAIN(\%OPT, @ARGV);


sub MAIN {
    my ($opt, @args) = @_;
    my (%repo, %image);
    my $horizon = parse_date("$OPT{keep_time} ago");
    die "Bad date" unless $horizon and $horizon lt parse_date("yesterday");

    for my $img (@{images()}) {
        $image{$$img{Id}} = $img;
        $$img{keep} = 1 if parse_date($$img{Created}) gt $horizon;
        for my $name (@{$$img{names}}) {
            die "Duplicate $name!" if $repo{$name};
            my ($repo, $tag) = split /:/, $name;
            if ($tag eq 'latest') {
                $$img{in_use} = 1;
            } else {
                # Don't tag the latest since it doesn't sort well
                $repo{$repo}{$tag} = $img;
            }
        }
    }

    for my $c (@{containers()}) {
        $image{$$c{Image}}{in_use} = 1;
    }

    for my $repo (keys %repo) {
        my $keep_major   = $OPT{keep_major};
        my $keep_history = $OPT{keep_history};
        my @tags = reverse natural_sort(keys %{$repo{$repo}});
        my $major = 0;
        my (@keep, @rm);
        for my $tag (@tags) {
            # First numerical value
            if ($tag =~ /(\d+)/ and $1 != $major) {
                $repo{$repo}{$tag}{keep} = 1 if $keep_major-- >= 0;
                $major = $1;
            }

            if ($repo{$repo}{$tag}{in_use}) {
                # must keep if in use even if keep_history is negative/invalid
                $repo{$repo}{$tag}{keep} = 1;
                $keep_history = $OPT{keep_history};
            }

            # use >= 0 since first match occurs on item itself, thus
            # keep-history = 1 will keep 2 images.
            if ($keep_history >= 0) {
                $keep_history--;
                $repo{$repo}{$tag}{keep} = 1;
            }

            $repo{$repo}{$tag}{keep} //= 0;
            $repo{$repo}{$tag}{keep} ? push(@keep, $tag) : push(@rm, $tag);
        }
        say $repo;
        say "  Keep:   @keep" if @keep;
        say "  Remove: @rm"   if @rm;
    }

    for (values %image) {
        next if defined($$_{keep});
        $$_{keep} = 1;
        say STDERR "Keeping unversioned image: @{$$_{names}}";
    }

    rmi( map $$_{Id}, grep !$$_{keep}, values %image );
}

sub containers {
    chomp(my @ids = qx| docker ps -q |);
    return inspect(@ids);
}

sub images {
    # skip first line (header)
    my (undef, @rows) = qx| docker images --no-trunc |;
    my (%names, %ids);
    for (@rows) {
        my ($repo, $tag, $id) = split;
        die "unexpected ':' in $repo" if $repo =~ /:/;
        $ids{$id}++;
        push @{$names{$id}}, "$repo:$tag";
    }
    my $inspected = inspect(keys %ids);
    for my $info (@$inspected) {
        die "Confused!" unless $names{$$info{Id}};
        $$info{names} = $names{$$info{Id}};
    }
    return $inspected;
}

sub inspect {
    die "Unexpected IDs: @_" if grep /[^0-9a-fA-F]/, @_;
    return [] unless @_;
    decode_json(qx| docker inspect @_ |);
}

sub rmi {
    die "Unexpected IDs: @_" if grep /[^0-9a-fA-F]/, @_;
    return unless @_;
    system docker => rmi => @_;
}

sub get_options {
    my $OPT = shift;
    GetOptions $OPT, @_ or usage(1);
    usage() if $$OPT{help} || $$OPT{version};
    lock_keys(%$OPT, keys %$OPT, map /^(\w+)/, @_);
}

sub usage {
    my $status = (@_ && $_[0] =~ /^\d+$/) ? shift(@_) : 0+@_;
    print @_, "\n" if @_;
    require File::Spec; my $exe = (File::Spec->splitpath($0))[2];
    $OPT{$_} = $OPT{$_} ? "enabled" : "disabled" for map /^(\w+).*!/, @OPT_SPEC;
    print $OPT{version} ? "$exe version $VERSION\n" : USAGE($exe);
    exit $status;
}
